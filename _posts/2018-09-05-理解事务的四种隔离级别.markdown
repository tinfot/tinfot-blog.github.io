---
layout: post
title:  "理解事务的四种隔离级别"
date:   2018-09-05 15:01:24 +0800
categories: MySQL
tags: MySQL
---

## 介绍

数据库事务的隔离级别有四种，由低到高分别是：`Read uncommitted`、 `Read committed`、 `Repeatable read` 和 `Serializable`。

而且，在事务的 **并发** 操作中可能会出现 **脏读**，**不可重复读** 和 **幻读**。

下面通过几个事例来阐述它们的概念与联系。

---

### Read uncommitted

**未提交读**，顾名思义，就是一个事务可以读取另一个 **未提交** 事务的数据。

> 事例：雇主要给雇员发薪水，雇员的薪水是1万/月。
但是发薪水的时候雇主输错了数字，将 `10000` 输入成 `100000`。
此时，薪水已经入到雇员的账户内，但是事务还没有提交。
就在此时，雇员登录自己的账户查看，发现比往常多了很多钱，以为是发奖金了非常高兴。
但是老板及时发现了情况不对，马上回滚了即将提交的事务，将数字改成了 `10000` 再提交。

分析得出：实际雇员当月薪资还是 `10000`，但是雇员看到的是 `100000`，他看到的是雇主当时还未提交事务的数据，这也就是 **脏读**。

怎么解决：`Read committed` --- **提交读**

---

### Read committed

**提交读**，顾名思义，就是一个事务要等另一个事务 **提交后** 才能读取数据。

> 事例：雇员拿着储蓄卡去享受生活（卡内余额还有 `10000` 元），当他需要进行结账时（开启结账事务），收费系统需要先检查账户内收费有足够的余额（获得检查结果，余额为 `10000` 元）。
就在此时，雇员的妻子需要用到 `10000` 元来补充家用，她提取了所有余额并提交了事务。现在我们回到刚刚的结账事务中，系统准备扣款时，再次检查账户内余额，发现余额已经为 `0` 元（因为刚刚雇员的妻子已经提取了所有余额并提交了事务）。此时雇员非常郁闷，明明卡里面是有 `10000` 元的。

分析得出：**提交读** --- 若有事务对数据进行更新操作室，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决 **脏读** 问题。在本次实例中，出现了==一个事务范围内两个相同的查询却得到了不同结果数据==，这就是 **不可重复读**。

怎么解决：`Repeatable read` --- **重复读**

---

### Repeatable read

**重复读**，当开始读取数据（开启事务）时，不再允许修改数据。

> 事例：雇员拿着储蓄卡去享受生活（卡内余额还有 `10000` 元），当他需要进行结账时（开启结账事务），收费系统需要先检查账户内收费有足够的余额（获得检查结果，余额为 `10000` 元）。
就在此时，雇员的妻子需要用到 `10000` 元来补充家用，但是现在雇员的妻子不能转出金额。接下来收费系统继续工作进行扣款。

分析得出：**重复读** --- 需要明白的一点就是 ==**不可重复读** 对应的是修改，但是可能还会有 **幻读** 的问题，因为 **幻读** 对应的是插入操作==。

> 事例：雇员某日去消费，花了 `2000` 元，然后雇员的妻子去查看雇员当日的消费记录（全表扫描FTS，雇员妻子开启事务），看到确实是花了 `2000` 元。就在此时，雇员花了 `5000` 元买了一部手机，即插入了一条消费记录，并提交了。当妻子打印雇员的消费记录清单时（提交事务），发现花了 `7000` 元，似乎出现了幻觉，这就是 **幻读**。

怎么解决：`Serializable` --- **序列化**

---

### Serializable

**序列化**，在该级别下面，事务以==串行化顺序执行==，可以避免 **脏读**、**不可重复读** 与 **幻读**，但是这种事务隔离级别的效率低下，比较耗数据库性能，一般不适用。

==值得一提的是：大多数数据库默认的事务隔离级别是 `Read committed`，比如 `SQL Server`、 `Orcle`。`MySQL` 的默认隔离级别是 `Repeatable read`。